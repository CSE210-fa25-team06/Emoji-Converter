# Meeting 10/13/2025  
**Time:** 3pm - 3:45pm  
**Scriber:** Jared  
**Attendance:** Isheta, Melvyn, Akshay, Lei, Patryk, Tej, Jared, Junjie, Siri, Adam, Austin, Alex, Tongke  

---

## Agenda

### One Thought/Improvement from Lecture Notes

**Isheta:** The article could add a short section about learning to take and use feedback. It already talks about discipline and growth, but getting better also means listening to others. Feedback is like a mirror, it helps you see things you might miss yourself. The article could mention how things like code reviews or project reflections are not just grading moments but chances to learn. It would also help to remind us that feedback isn’t personal, it’s just information to help you improve. This acts as a bridge between individual and team development.  

**Melvyn:** Mentorship and collaboration help developers grow by providing guidance during onboarding and creating opportunities to learn new skills, explore tools, and share experiences that support their adaptation to a new role.  

**Akshay:**  

**Lei:** The idea of "You ≠ Your Code" is meant to separate your self-worth from the quality of your code. But sometimes, it can backfire—people either get overly proud when their code is great, or feel personally attacked when it's criticized. Here’s how I see it: A healthier way to look at it is to tie your value to your ability to solve problems and your willingness to keep learning. “Bad” code doesn’t mean you failed—it just means there’s something to improve, or a chance to learn something new. When someone points out issues in a code review, they’re not judging you—they’re trying to help make the solution better. Your worth isn’t about writing perfect code that never breaks. It’s about being open to feedback, learning from mistakes, and coming back with better solutions. That kind of growth mindset is what really matters.  

**Patryk:** When discussing 10x developers, it's crucial to connect it to the concept of impostor syndrome. We often don't realize how much other people don't know; they might just be more confident, more knowledgeable in one particular area, or simply great at speaking. Ultimately, everyone is probably about as clueless as we are unless they have a significant number of additional years of experience. It's important to remember that at one point, even the experts were as clueless as a novice, and we can always reach their level, or at least get close to it, over time. It is a natural position to be in, as everyone is a beginner developer at some point. I also appreciate the mention of the need to master soft skills. The more experience I gain in software engineering, the more I realize their importance for complex, team-based projects. A prime example is the Linux kernel development space and its dramas; despite the conflicts, they somehow make it work, largely through a strong and experienced leader (or, as some might say, a dictator). This shows that being a good leader is something we should all strive for, and we must aim to improve our soft skills just as much as our programming abilities.  

**Tej:** In the section(s) on team communication, I would like to have seen a discussion on communication in person vs. online. I think this is an especially important topic in today’s SWE world, because we have different team compositions across the world and remote work/days for employees. There are a lot of pros/cons with having a team communicate in person and vice versa online. In addition, in the team size section, I would have also liked to have seen this topic addressed. Should we have multinational teams across the globe? In one way, it allows for more people to work on constantly, but on the other hand, it might hinder communication. For example, a lot of teams are split between India and the West Coast. These two regions are basically on the opposite side of the world in terms of time zones which leaves only a couple hours where communication can happen. What happens when someone in the US needs the help of an Indian team member? Either person would have to compromise their livelihood to accommodate. Is this the most productive way to build software? I think these questions and thoughts should be addressed.  

**Jared:** There is some discussion about selfish vs selfless devs, but there should be some mention that one can be too selfless as a developer. One should be able to discern when they are being selfish from when they are taking necessary rest to ensure they have optimal productivity and clean code. Taking on too much work for the team may actually reduce overall productivity just from lack of rest. One should also feel comfortable (touching on the soft skills point) talking to their team to communicate when they feel like they have taken on too much work, so that other members can help alleviate their load.  

**Junjie:** The note could add a few concrete, real-world examples. For instance, showing how a developer might practice purposefully when learning a new framework, or how to recognize and recover from distraction during coding, would make the advice feel more actionable.  

**Siri:** Could add a small section on how to handle conflicts or misunderstandings within a team. Working with people can be hard sometimes so learning how to resolve issues is important so it doesn’t affect the team’s performance. Since we deal with software at a large scale which comes with a lot of complexity, team communication and good understanding is really important. We can’t completely avoid conflicts so learning to resolve them is essential.  

**Adam:**  

**Austin:** The lecture notes should add a section on the benefits of having a supportive team environment. A team environment that encourages people to proactively ask for help when they are struggling will discourage teammates from choosing to stay silent when a problem arises out of a fear of looking incompetent to the other people on their team. A supportive team environment can also boost morale on the team, which can motivate people to put more effort into their work than they otherwise would in a toxic team environment. I also believe that friendships will naturally form in a supportive team environment, which can lead to improved communication within the team because each team member understands their teammates on a personal level.  

**Alex:** I like how the lecture touches on managers and how SWEs in general should understand management and management techniques even if they don’t plan to become a leader in the future. I think this is an important point because understanding how leaders think and operate can help engineers work more effectively within a team. However, I also think it’s worth mentioning that many entry-level engineers often don’t realize this early on. To some engineers, the focus is usually on writing good code rather than understanding team dynamics or leadership goals. This again ties back to the earlier notes that software engineering is a human game, not just from the top-down perspective where leaders choose and guide good engineers, but also from the bottom-up, where engineers should take time to understand their leaders. I think this section could be elaborated on how engineers can effectively interact with leaders and whether or not they should view leaders as adversarial or beneficial.  

**Tongke:** In the part "Organizational cultures", the author lists the three organizational types but doesn’t explain how each one affects software teams. Without that context, readers may struggle to connect the theory to their real work environment. Adding a short explanation (based on my own understanding) would help:  
- **Pathological (Power-Oriented):** Information is controlled and used for personal advantage; blame and fear often dominate.  
- **Bureaucratic (Rule-Oriented):** Processes and hierarchy guide communication; information moves through formal channels.  
- **Generative (Performance-Oriented):** Information flows freely; collaboration, trust, and innovation are encouraged.  
Including these brief descriptions would make the framework more concrete and show how each structure shapes a team’s effectiveness.  

---

## Updates from Each Team

### Front-End
- Worked on Figma design (need to invite rest of team to the Figma - doing after meeting)  
- Probably going to remove the history tab to reduce complexity  
- Have emoji keyboard pop up when the user clicks on the emoji field  

**TODO:**  
- Implement frontend  

---

### Back-End
- Now have a base of all the emojis contained in it, based on CLDR Unicode (contains all TTS data)  
- Not quite agreed on specific methods for emoji → text and vice versa  
- Have a script inside the repo to gather the latest data from the CLDR repo. Updates every time the repo updates to ensure emoji database is up to date  
- Initially not using ML — using start-of-string scanner to pull largest possible match to emoji (for text → emoji), emoji → text is trivial using mapping  
- May need to use ML at some point, but this solution is good for now  
- Base structure for server set up (Flask framework) — 2 API endpoints and developing logic  
- Clarify if Python is acceptable for backend — HTML, CSS, JS for frontend only?  
- Timeline depends on implementation. Smallest one (literal translation) would be quick — probably done within a day or two  
- Plan on implementing the literal translation first while waiting for confirmation from TA  
- Will user be able to input text with emoji?  
  - For now assume user can input either text or emoji, not both  
- Comments: establish what exact translation we need — does grammar need to be correct? That may require ML. Ask for more specification from professor or implement ML after finishing the initial program  

**TODO:**  
- Implement minimum product  
- Work with frontend team to connect frontend and backend  

---

### Testing
- Modified backend script so that emoji dataset is translated into a JSON file  
- Script that parses emoji dataset into manipulatable format  
- Basic testing suite to run test cases on emoji translator — made a dummy translator function that returns a static value just to ensure tools are working properly  
- Made a few test cases that test whether the translator works correctly based on downloaded dataset — and vice versa  
- To make sure the test cases are working properly  
- Once backend team has functionality they’re happy with, can hook up tools to the actual translator to validate  

**TODO:**  
- When backend team finishes implementation, hook up testing suite to backend (backend timeline has implementation done tomorrow)  

---

### DevOps
- Have an HTML validator, CSS and JS linter in place  
- Will run whenever you commit. Checks whether syntax and structure are correct  
- Specifications in `eslint.config` in `dev-ops` branch  
- Can also make a Python validator for backend  
- Alex is going to work on the GitHub Pages to host the main branch (for demos)  
- Use meaningful comments when writing code as other people will be looking at it  

**TODO:**  
- GitHub pages
- GitHub action for the CLDR dataset